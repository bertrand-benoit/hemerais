#!/bin/bash
#
# Hemera - Intelligent System (https://sourceforge.net/projects/hemerais)
# Copyright (C) 2010-2011 Bertrand Benoit <projettwk@users.sourceforge.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see http://www.gnu.org/licenses
# or write to the Free Software Foundation,Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA 02110-1301  USA
#
# Version: 1.0
# Description: search command.
# Keyword: SEARCH_CMD
#
# This script must NOT be directly called.

## Checks configuration specific to this command.
function checkConfig() {
  checkAndSetConfig "hemera.core.command.general.htmlConverter.path" "$CONFIG_TYPE_BIN"
  export htmlConverter="$h_lastConfig"
  checkAndSetConfig "hemera.core.command.general.fileSplitter.path" "$CONFIG_TYPE_BIN"
  export fileSplitter="$h_lastConfig"
  checkAndSetConfig "hemera.core.command.search.url" "$CONFIG_TYPE_OPTION"
  export searchURL="$h_lastConfig"

  return 0
}

## Performs a quick test of this command.
function testCommand() {
  # TODO: implement test
  return 0
}

## Instructions - concrete execution of this command.
# usage: checkCoherence <path of the whole input> <words count>
#  <path of the whole input>: contains all the recognized input
#  <words count>: the count of recognized words
# return 0 if coherence if OK, >0 otherwise.
function checkCoherence() {
  local _inputPath="$1" _wordsCount="$2"

  # Ensures there is at least one argument.
  if [ $_wordsCount -lt 2 ]; then
    speechToSay "$SEARCH_CMD_BAD_USE_I18N" "$_inputPath"
    return 1
  fi

  # All is OK.
  return 0
}

## Instructions - concrete execution of this command.
# usage: parseHTML <source URL> <source file> <destination file>
function parseHTML() {
  local _srcURL="$1" _srcfile="$2" _destFile="$3"
  local _txtFile="$_destFile.tmp"

  # Converts HTML to text.
  "$htmlConverter" -o "$_txtFile" "$_srcfile" >>"$h_logFile" 2>&1 || errorMessage "Unable to convert HTML of file '$_srcfile'" $ERROR_EXTERNAL_TOOL

  # Additional parsing according to search URL.
  if [[ "$_srcURL" =~ ".*mobile.wikipedia.*" ]]; then
    # Extracts contents part (will be in file numbered 1).
    # TODO: use -2 instead of 0, but manage error case where there is not enough lines.
    "$fileSplitter" -n 1 -qz -f "$_destFile" "$_txtFile" "/========/1" "/========/0" >>"$h_logFile" 2>&1 || errorMessage "Unable to split file '$_txtFile'" $ERROR_EXTERNAL_TOOL

    # Final parsing:
    #  - removes line containing only element in brackets
    #  - replaces all "_" by space
    #  - adds a space at the end of each line, and then removes line break
    #  - removes words in bracket, taking care of potential "bug" like "[roue] s,"
    #  - replaces some remaining html code (e.g. &quot;)
    cat "$_destFile"1 \
      |sed -e 's/^[[].*[]]$//g;s/\([^-]\)$/\1 /g;s/^[ \t]*D[Ã©e]finition[ \t]*$//g;' |tr -d '\n' \
      |sed -e 's/[[]\([^]]*\)[]][ ]s\([[:punct:]]\)/\1s\2/g;s/[[]\([^]]*\)[]]/\1/g;' \
      |sed -e 's/&quot;/"/g;s/_/ /g;' \
    > "$_destFile"
  else
    warning "There is currently no additional parsing for source URL '$_srcURL' (result may not be good). Contact Hemera team to implement it."
    mv -f "$_txtFile" "$_destFile" 
  fi
}

# usage: execute <path of the whole input> <input string presentation>
#  <path of the whole input>: contains all the recognized input
#  <input string presentation>: the string presentation of the input (prefix of message to show)
# return 0 if execution if OK, >0 otherwise.
function execute() {
  checkConfig || return 1

  local _inputPath="$1" _inputString="$2"

  # Extracts the term to define.
  termsToDefine=$( extractRecognitionResultArgument "$_inputPath" )
  writeMessage "$_inputString: SEARCH command detected -> starting definition search about: $termsToDefine"

  # Gets the corresponding URL.
  input=$( echo "$termsToDefine" |sed -e 's/[ \t]/%20/g;' )
  urlContentsFile="$h_workDir/$h_fileDate-DefinitionContents.tmp"
  getURLContents $( eval echo "$searchURL" ) "$urlContentsFile" || exit $ERROR_EXTERNAL_TOOL

  # Parses HTML.
  parseHTML "$searchURL" "$urlContentsFile" "$urlContentsFile.txt"

  # Uses the speech core module to read the produced file.
  h_logFile="$h_logFile" noconsole=1 "$speechScript" -f "$urlContentsFile.txt" -o "$h_newInputDir/speech_"$( basename "$_inputPath" )".wav"
}
